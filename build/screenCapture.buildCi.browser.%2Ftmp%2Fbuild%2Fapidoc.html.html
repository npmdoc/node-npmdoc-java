<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/joeferner/node-java#readme">java (v0.8.0)</a>
</h1>
<h4>Bridge API to connect with existing Java APIs.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.java">module java</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.ensureJvm">
            function <span class="apidocSignatureSpan">java.</span>ensureJvm
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.import">
            function <span class="apidocSignatureSpan">java.</span>import
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.isJvmCreated">
            function <span class="apidocSignatureSpan">java.</span>isJvmCreated
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.onJvmCreated">
            function <span class="apidocSignatureSpan">java.</span>onJvmCreated
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.registerClient">
            function <span class="apidocSignatureSpan">java.</span>registerClient
            <span class="apidocSignatureSpan">(before, after)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.registerClientP">
            function <span class="apidocSignatureSpan">java.</span>registerClientP
            <span class="apidocSignatureSpan">(beforeP, afterP)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">java.</span>asyncOptions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">java.</span>classpath</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">java.</span>nodeJavaBridge</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">java.</span>options</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">java.</span>testAsyncSuffixSyncDefault</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">java.</span>testDefactoPlusPromise</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">java.</span>nativeBindingLocation</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.java.classpath">module java.classpath</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.classpath.pushDir">
            function <span class="apidocSignatureSpan">java.classpath.</span>pushDir
            <span class="apidocSignatureSpan">(dir)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">java.classpath.</span>0</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">java.classpath.</span>1</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">java.classpath.</span>10</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">java.classpath.</span>11</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">java.classpath.</span>12</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">java.classpath.</span>13</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">java.classpath.</span>14</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">java.classpath.</span>15</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">java.classpath.</span>16</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">java.classpath.</span>17</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">java.classpath.</span>18</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">java.classpath.</span>19</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">java.classpath.</span>2</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">java.classpath.</span>3</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">java.classpath.</span>4</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">java.classpath.</span>5</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">java.classpath.</span>6</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">java.classpath.</span>7</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">java.classpath.</span>8</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">java.classpath.</span>9</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.java.nodeJavaBridge">module java.nodeJavaBridge</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.nodeJavaBridge.ensureJvm">
            function <span class="apidocSignatureSpan">java.nodeJavaBridge.</span>ensureJvm
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.nodeJavaBridge.import">
            function <span class="apidocSignatureSpan">java.nodeJavaBridge.</span>import
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.nodeJavaBridge.isJvmCreated">
            function <span class="apidocSignatureSpan">java.nodeJavaBridge.</span>isJvmCreated
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.nodeJavaBridge.onJvmCreated">
            function <span class="apidocSignatureSpan">java.nodeJavaBridge.</span>onJvmCreated
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.nodeJavaBridge.registerClient">
            function <span class="apidocSignatureSpan">java.nodeJavaBridge.</span>registerClient
            <span class="apidocSignatureSpan">(before, after)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.nodeJavaBridge.registerClientP">
            function <span class="apidocSignatureSpan">java.nodeJavaBridge.</span>registerClientP
            <span class="apidocSignatureSpan">(beforeP, afterP)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">java.nodeJavaBridge.</span>asyncOptions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">java.nodeJavaBridge.</span>classpath</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">java.nodeJavaBridge.</span>options</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">java.nodeJavaBridge.</span>nativeBindingLocation</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.java.testAsyncSuffixSyncDefault">module java.testAsyncSuffixSyncDefault</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.testAsyncSuffixSyncDefault.launch">
            function <span class="apidocSignatureSpan">java.testAsyncSuffixSyncDefault.</span>launch
            <span class="apidocSignatureSpan">(test)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.testAsyncSuffixSyncDefault.testAPI">
            function <span class="apidocSignatureSpan">java.testAsyncSuffixSyncDefault.</span>testAPI
            <span class="apidocSignatureSpan">(test)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.testAsyncSuffixSyncDefault.testAlternateMethodNameWorks">
            function <span class="apidocSignatureSpan">java.testAsyncSuffixSyncDefault.</span>testAlternateMethodNameWorks
            <span class="apidocSignatureSpan">(test)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.testAsyncSuffixSyncDefault.testAsyncCalls">
            function <span class="apidocSignatureSpan">java.testAsyncSuffixSyncDefault.</span>testAsyncCalls
            <span class="apidocSignatureSpan">(test)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.testAsyncSuffixSyncDefault.testImportClass">
            function <span class="apidocSignatureSpan">java.testAsyncSuffixSyncDefault.</span>testImportClass
            <span class="apidocSignatureSpan">(test)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.testAsyncSuffixSyncDefault.testReservedFieldName">
            function <span class="apidocSignatureSpan">java.testAsyncSuffixSyncDefault.</span>testReservedFieldName
            <span class="apidocSignatureSpan">(test)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.testAsyncSuffixSyncDefault.testStaticAPI">
            function <span class="apidocSignatureSpan">java.testAsyncSuffixSyncDefault.</span>testStaticAPI
            <span class="apidocSignatureSpan">(test)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.testAsyncSuffixSyncDefault.testStaticSyncCalls">
            function <span class="apidocSignatureSpan">java.testAsyncSuffixSyncDefault.</span>testStaticSyncCalls
            <span class="apidocSignatureSpan">(test)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.testAsyncSuffixSyncDefault.testSyncCalls">
            function <span class="apidocSignatureSpan">java.testAsyncSuffixSyncDefault.</span>testSyncCalls
            <span class="apidocSignatureSpan">(test)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.testAsyncSuffixSyncDefault.testUnusableMethodNameThrows">
            function <span class="apidocSignatureSpan">java.testAsyncSuffixSyncDefault.</span>testUnusableMethodNameThrows
            <span class="apidocSignatureSpan">(test)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.java.testDefactoPlusPromise">module java.testDefactoPlusPromise</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.testDefactoPlusPromise.launch">
            function <span class="apidocSignatureSpan">java.testDefactoPlusPromise.</span>launch
            <span class="apidocSignatureSpan">(test)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.testDefactoPlusPromise.testAPI">
            function <span class="apidocSignatureSpan">java.testDefactoPlusPromise.</span>testAPI
            <span class="apidocSignatureSpan">(test)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.testDefactoPlusPromise.testAsyncCalls">
            function <span class="apidocSignatureSpan">java.testDefactoPlusPromise.</span>testAsyncCalls
            <span class="apidocSignatureSpan">(test)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.testDefactoPlusPromise.testImportClass">
            function <span class="apidocSignatureSpan">java.testDefactoPlusPromise.</span>testImportClass
            <span class="apidocSignatureSpan">(test)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.testDefactoPlusPromise.testPromiseCalls">
            function <span class="apidocSignatureSpan">java.testDefactoPlusPromise.</span>testPromiseCalls
            <span class="apidocSignatureSpan">(test)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.testDefactoPlusPromise.testStaticAPI">
            function <span class="apidocSignatureSpan">java.testDefactoPlusPromise.</span>testStaticAPI
            <span class="apidocSignatureSpan">(test)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.testDefactoPlusPromise.testStaticSyncCalls">
            function <span class="apidocSignatureSpan">java.testDefactoPlusPromise.</span>testStaticSyncCalls
            <span class="apidocSignatureSpan">(test)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.java.testDefactoPlusPromise.testSyncCalls">
            function <span class="apidocSignatureSpan">java.testDefactoPlusPromise.</span>testSyncCalls
            <span class="apidocSignatureSpan">(test)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.java" id="apidoc.module.java">module java</a></h1>


    <h2>
        <a href="#apidoc.element.java.ensureJvm" id="apidoc.element.java.ensureJvm">
        function <span class="apidocSignatureSpan">java.</span>ensureJvm
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensureJvm = function (callback) {

  // First see if the promise-style API should be used.
  // This must be done first in order to ensure the proper API is used.
  if (_.isUndefined(callback) &amp;&amp; java.asyncOptions &amp;&amp; _.isFunction(java.asyncOptions.promisify)) {
    // Create a promisified version of this function.
    var launchJvmPromise = java.asyncOptions.promisify(java.ensureJvm.bind(java));
    // Call the promisified function, returning its result, which should be a promise.
    return launchJvmPromise();
  }

  // If we get here, callback must be a node-style callback function. If not, throw an error.
  else if (!_.isFunction(callback)) {
    throw new Error('java.launchJvm(cb) requires its one argument to be a callback function.');
  }

  // Now check if the JVM has already been created. If so, we assume that the jvm was already successfully
  // launched, and we can just implement idempotent behavior, i.e. silently notify that the JVM has been created.
  else if (java.isJvmCreated()) {
    return setImmediate(callback);
  }

  // Finally, queue the initializeAll function.
  else {
    return setImmediate(initializeAll, callback);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#### NOTES:
* If you want the defacto standard behavior, simply don't set java.asyncOptions.
* If you do provide asyncOptions, be aware that this module will not generate method variants of a given flavor if you don'
t provide a string value for the corresponding suffix (`asyncSuffix`, `syncSuffix`, `promiseSuffix`). In the example above, the
application is configured to omit the method variants using node-style async callback functions.
* If you provide `asyncOptions.promiseSuffix` then you must also set `asyncOptions.promisify` to a function that *promisifies* a
 node-style async function. I.e. the provided function must take as input a function whose last argument is a node callback function
, and it must return an equivalent promise-returning function. Several Promises/A+ libraries provide such functions, but it may
be necessary to provide a wrapper function. See `testHelpers.js` for an example.
* If you provide `asyncOptions.promisify` then you must provide a *non-empty* string for `asyncOptions.promiseSuffix`.
* Either (but not both) `asyncSuffix` or `syncSuffix` can be the empty string. If you want the defacto standard behavior for no
suffix on async methods, you must provide an empty string for `asyncSuffix`.
* We've tested promises with five Promises/A+ implementations. See `testHelpers.js` for more information.
* NOTE: Due to specifics of initialization order, the methods  `java.newInstancePromise`, `java.callMethodPromise`, and `java.callStaticMethodPromise
` are not available until the JVM has been created. You may need to call some other java method such as `java.import()` to finalize
 java initialization, or even better, the function `java.<span class="apidocCodeKeywordSpan">ensureJvm</span>()`.

##### Special note about the exported module functions `newInstance`, `callMethod`, and `callStaticMethod`.
These methods come in both async and sync variants. If you provide the `promisify` and `promiseSuffix` attributes in asyncOptions
 then you'll also get the Promises/A+ variant for these three functions. However, if you change the defacto
conventions for the `syncSuffix` (i.e. 'Sync') and/or `asyncSuffix` (i.e. '') it will not affect the naming
for these three functions. I.e. no matter what you specify in asyncOptions, the async variants are named `newInstance`, `callMethod
`, and `callStaticMethod`, and the sync variants are named `newInstanceSync`, `callMethodSync`, and `callStaticMethodSync`.

## Varargs support
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.java.import" id="apidoc.element.java.import">
        function <span class="apidocSignatureSpan">java.</span>import
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">import = function (name) {
  var clazz = java.findClassSync(name); // TODO: change to Class.forName when classloader issue is resolved.
  var result = function javaClassConstructorProxy() {
    var args = [name];
    for (var i = 0; i &lt; arguments.length; i++) {
      args.push(arguments[i]);
    }
    return java.newInstanceSync.apply(java, args);
  };
  var i;

  result.class = clazz;

  // copy static fields
  var fields = SyncCall(clazz, 'getDeclaredFields')();
  for (i = 0; i &lt; fields.length; i++) {
    var modifiers = SyncCall(fields[i], 'getModifiers')();
    if (((modifiers &amp; MODIFIER_PUBLIC) === MODIFIER_PUBLIC)
      &amp;&amp; ((modifiers &amp; MODIFIER_STATIC) === MODIFIER_STATIC)) {
      var fieldName = SyncCall(fields[i], 'getName')();
      var jsfieldName = usableName(fieldName);
      result.__defineGetter__(jsfieldName, function(name, fieldName) {
        return java.getStaticFieldValue(name, fieldName);
      }.bind(this, name, fieldName));
      result.__defineSetter__(jsfieldName, function(name, fieldName, val) {
        java.setStaticFieldValue(name, fieldName, val);
      }.bind(this, name, fieldName));
    }
  }

  var promisify = undefined;
  var promiseSuffix;
  if (java.asyncOptions &amp;&amp; java.asyncOptions.promisify) {
    promisify = java.asyncOptions.promisify;
    promiseSuffix = java.asyncOptions.promiseSuffix;
  }

  // copy static methods
  var methods = SyncCall(clazz, 'getDeclaredMethods')();
  for (i = 0; i &lt; methods.length; i++) {
    var modifiers = SyncCall(methods[i], 'getModifiers')();
    if (((modifiers &amp; MODIFIER_PUBLIC) === MODIFIER_PUBLIC)
      &amp;&amp; ((modifiers &amp; MODIFIER_STATIC) === MODIFIER_STATIC)) {
      var methodName = SyncCall(methods[i], 'getName')();

      if (_.isString(syncSuffix)) {
        var syncName = usableName(methodName + syncSuffix);
        result[syncName] = java.callStaticMethodSync.bind(java, name, methodName);
      }

      if (_.isString(asyncSuffix)) {
        var asyncName = usableName(methodName + asyncSuffix);
        result[asyncName] = java.callStaticMethod.bind(java, name, methodName);
      }

      if (promisify &amp;&amp; _.isString(promiseSuffix)) {
        var promiseName = usableName(methodName + promiseSuffix);
        result[promiseName] = promisify(java.callStaticMethod.bind(java, name, methodName));
      }
    }
  }

  // copy static classes/enums
  var classes = SyncCall(clazz, 'getDeclaredClasses')();
  for (i = 0; i &lt; classes.length; i++) {
    var modifiers = SyncCall(classes[i], 'getModifiers')();
    if (((modifiers &amp; MODIFIER_PUBLIC) === MODIFIER_PUBLIC)
      &amp;&amp; ((modifiers &amp; MODIFIER_STATIC) === MODIFIER_STATIC)) {
      var className = SyncCall(classes[i], 'getName')();
      var simpleName = SyncCall(classes[i], 'getSimpleName')();
      Object.defineProperty(result, simpleName, {
        get: function(result, simpleName, className) {
          var c = java.import(className);

          // memoize the import
          var d = Object.getOwnPropertyDescriptor(result, simpleName);
          d.get = function(c) { return c; }.bind(null, c);
          Object.defineProperty(result, simpleName, d);

          return c;
        }.bind(this, result, simpleName, className),
        enumerable: true,
        configurable: true
      });
    }
  }

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
npm install java
```

Then create a file called `test.js` with the following contents

```
var java = require('java');
var javaLangSystem = java.<span class="apidocCodeKeywordSpan">import</span>('java.lang.System');

javaLangSystem.out.printlnSync('Hello World');
```

Then run

```bash
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.java.isJvmCreated" id="apidoc.element.java.isJvmCreated">
        function <span class="apidocSignatureSpan">java.</span>isJvmCreated
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isJvmCreated = function () {
  return typeof java.onJvmCreated !== 'function';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
    });

    var thread = java.newInstanceSync("java.lang.Thread", myProxy);
    thread.start();

&lt;a name="javaisJvmCreated" /&gt;
**java.<span class="apidocCodeKeywordSpan">isJvmCreated</span>()**

Returns true if the JVM has been created. The JVM can only be created once.

&lt;a name="javaRegisterClient" /&gt;
**java.registerClient(before, after)**

Register that a client wants to be called back immediately before and/or immediately after the JVM is created. If used, this function
 must be called before the JVM has been created. The before function is typically used to add to the classpath. The function may
 execute asynchronous operations (such as a async glob function). The after function is sometimes useful for doing one-time initialization
 that requires the JVM to first be initialized. If either function is unnecessary, use `null` or `undefined`. See also `registerClientP
` and `ensureJvm`. See the unit tests in `testAsyncOptions` for examples.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.java.onJvmCreated" id="apidoc.element.java.onJvmCreated">
        function <span class="apidocSignatureSpan">java.</span>onJvmCreated
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onJvmCreated = function () {
  if (java.asyncOptions) {
    syncSuffix = java.asyncOptions.syncSuffix;
    asyncSuffix = java.asyncOptions.asyncSuffix;
    if (typeof syncSuffix !== 'string') {
      throw new Error('In asyncOptions, syncSuffix must be defined and must a string');
    }
    var promiseSuffix = java.asyncOptions.promiseSuffix;
    var promisify = java.asyncOptions.promisify;
    if (typeof promiseSuffix === 'string' &amp;&amp; typeof promisify === 'function') {
      var methods = ['newInstance', 'callMethod', 'callStaticMethod'];
      methods.forEach(function (name) {
        java[name + promiseSuffix] = promisify(java[name]);
      });
    } else if (typeof promiseSuffix === 'undefined' &amp;&amp; typeof promisify === 'undefined') {
      // no promises
    } else {
      throw new Error('In asyncOptions, if either promiseSuffix or promisify is defined, both most be.');
    }

    if (_.isString(java.asyncOptions.ifReadOnlySuffix) &amp;&amp; java.asyncOptions.ifReadOnlySuffix !== '') {
      ifReadOnlySuffix = java.asyncOptions.ifReadOnlySuffix;
    }
  } else {
    syncSuffix = 'Sync';
    asyncSuffix = '';
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.java.registerClient" id="apidoc.element.java.registerClient">
        function <span class="apidocSignatureSpan">java.</span>registerClient
        <span class="apidocSignatureSpan">(before, after)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerClient = function (before, after) {
  var before_, after_;
  if (java.isJvmCreated()) {
    throw new Error('java.registerClient() called after JVM already created.');
  }
  before_ = (before &amp;&amp; before.length === 0) ?
    function(cb) { before(); cb(); } :
    before;

  after_ = (after &amp;&amp; after.length === 0) ?
    function(cb) { after(); cb(); } :
    after;

  clients.push({before: before_, after: after_});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;a name="javaisJvmCreated" /&gt;
**java.isJvmCreated()**

Returns true if the JVM has been created. The JVM can only be created once.

&lt;a name="javaRegisterClient" /&gt;
**java.<span class="apidocCodeKeywordSpan">registerClient</span>(before, after)**

Register that a client wants to be called back immediately before and/or immediately after the JVM is created. If used, this function
 must be called before the JVM has been created. The before function is typically used to add to the classpath. The function may
 execute asynchronous operations (such as a async glob function). The after function is sometimes useful for doing one-time initialization
 that requires the JVM to first be initialized. If either function is unnecessary, use `null` or `undefined`. See also `registerClientP
` and `ensureJvm`. See the unit tests in `testAsyncOptions` for examples.

&lt;a name="javaRegisterClientP" /&gt;
**java.registerClientP(before, after)**

Like java.registerClient, but before and after are assumed to be functions returning promises.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.java.registerClientP" id="apidoc.element.java.registerClientP">
        function <span class="apidocSignatureSpan">java.</span>registerClientP
        <span class="apidocSignatureSpan">(beforeP, afterP)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerClientP = function (beforeP, afterP) {
  if (java.isJvmCreated()) {
    throw new Error('java.registerClient() called after JVM already created.');
  }
  clients.push({beforeP: beforeP, afterP: afterP});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;a name="javaRegisterClient" /&gt;
**java.registerClient(before, after)**

Register that a client wants to be called back immediately before and/or immediately after the JVM is created. If used, this function
 must be called before the JVM has been created. The before function is typically used to add to the classpath. The function may
 execute asynchronous operations (such as a async glob function). The after function is sometimes useful for doing one-time initialization
 that requires the JVM to first be initialized. If either function is unnecessary, use `null` or `undefined`. See also `registerClientP
` and `ensureJvm`. See the unit tests in `testAsyncOptions` for examples.

&lt;a name="javaRegisterClientP" /&gt;
**java.<span class="apidocCodeKeywordSpan">registerClientP</span>(before, after)**

Like java.registerClient, but before and after are assumed to be functions returning promises.

&lt;a name="javaEnsureJvm" /&gt;
**java.ensureJvm(callback)**

If the JVM has not yet been created, execute the full JVM initialization process, then call callback function when initialization
 is complete. If the JVM has been created, just call the callback. Note that the full initialization process includes: 1) executing
 all registered client *before* hooks, 2) creating the JVM, then 3) executing all registered client *after* hooks.
...</pre></li>
    </ul>
















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.java.classpath" id="apidoc.module.java.classpath">module java.classpath</a></h1>


    <h2>
        <a href="#apidoc.element.java.classpath.pushDir" id="apidoc.element.java.classpath.pushDir">
        function <span class="apidocSignatureSpan">java.classpath.</span>pushDir
        <span class="apidocSignatureSpan">(dir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pushDir = function (dir) {
  fs.readdirSync(dir).forEach(function(file) {
    java.classpath.push(path.resolve(dir, file));
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.java.nodeJavaBridge" id="apidoc.module.java.nodeJavaBridge">module java.nodeJavaBridge</a></h1>


    <h2>
        <a href="#apidoc.element.java.nodeJavaBridge.ensureJvm" id="apidoc.element.java.nodeJavaBridge.ensureJvm">
        function <span class="apidocSignatureSpan">java.nodeJavaBridge.</span>ensureJvm
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensureJvm = function (callback) {

  // First see if the promise-style API should be used.
  // This must be done first in order to ensure the proper API is used.
  if (_.isUndefined(callback) &amp;&amp; java.asyncOptions &amp;&amp; _.isFunction(java.asyncOptions.promisify)) {
    // Create a promisified version of this function.
    var launchJvmPromise = java.asyncOptions.promisify(java.ensureJvm.bind(java));
    // Call the promisified function, returning its result, which should be a promise.
    return launchJvmPromise();
  }

  // If we get here, callback must be a node-style callback function. If not, throw an error.
  else if (!_.isFunction(callback)) {
    throw new Error('java.launchJvm(cb) requires its one argument to be a callback function.');
  }

  // Now check if the JVM has already been created. If so, we assume that the jvm was already successfully
  // launched, and we can just implement idempotent behavior, i.e. silently notify that the JVM has been created.
  else if (java.isJvmCreated()) {
    return setImmediate(callback);
  }

  // Finally, queue the initializeAll function.
  else {
    return setImmediate(initializeAll, callback);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#### NOTES:
* If you want the defacto standard behavior, simply don't set java.asyncOptions.
* If you do provide asyncOptions, be aware that this module will not generate method variants of a given flavor if you don'
t provide a string value for the corresponding suffix (`asyncSuffix`, `syncSuffix`, `promiseSuffix`). In the example above, the
application is configured to omit the method variants using node-style async callback functions.
* If you provide `asyncOptions.promiseSuffix` then you must also set `asyncOptions.promisify` to a function that *promisifies* a
 node-style async function. I.e. the provided function must take as input a function whose last argument is a node callback function
, and it must return an equivalent promise-returning function. Several Promises/A+ libraries provide such functions, but it may
be necessary to provide a wrapper function. See `testHelpers.js` for an example.
* If you provide `asyncOptions.promisify` then you must provide a *non-empty* string for `asyncOptions.promiseSuffix`.
* Either (but not both) `asyncSuffix` or `syncSuffix` can be the empty string. If you want the defacto standard behavior for no
suffix on async methods, you must provide an empty string for `asyncSuffix`.
* We've tested promises with five Promises/A+ implementations. See `testHelpers.js` for more information.
* NOTE: Due to specifics of initialization order, the methods  `java.newInstancePromise`, `java.callMethodPromise`, and `java.callStaticMethodPromise
` are not available until the JVM has been created. You may need to call some other java method such as `java.import()` to finalize
 java initialization, or even better, the function `java.<span class="apidocCodeKeywordSpan">ensureJvm</span>()`.

##### Special note about the exported module functions `newInstance`, `callMethod`, and `callStaticMethod`.
These methods come in both async and sync variants. If you provide the `promisify` and `promiseSuffix` attributes in asyncOptions
 then you'll also get the Promises/A+ variant for these three functions. However, if you change the defacto
conventions for the `syncSuffix` (i.e. 'Sync') and/or `asyncSuffix` (i.e. '') it will not affect the naming
for these three functions. I.e. no matter what you specify in asyncOptions, the async variants are named `newInstance`, `callMethod
`, and `callStaticMethod`, and the sync variants are named `newInstanceSync`, `callMethodSync`, and `callStaticMethodSync`.

## Varargs support
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.java.nodeJavaBridge.import" id="apidoc.element.java.nodeJavaBridge.import">
        function <span class="apidocSignatureSpan">java.nodeJavaBridge.</span>import
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">import = function (name) {
  var clazz = java.findClassSync(name); // TODO: change to Class.forName when classloader issue is resolved.
  var result = function javaClassConstructorProxy() {
    var args = [name];
    for (var i = 0; i &lt; arguments.length; i++) {
      args.push(arguments[i]);
    }
    return java.newInstanceSync.apply(java, args);
  };
  var i;

  result.class = clazz;

  // copy static fields
  var fields = SyncCall(clazz, 'getDeclaredFields')();
  for (i = 0; i &lt; fields.length; i++) {
    var modifiers = SyncCall(fields[i], 'getModifiers')();
    if (((modifiers &amp; MODIFIER_PUBLIC) === MODIFIER_PUBLIC)
      &amp;&amp; ((modifiers &amp; MODIFIER_STATIC) === MODIFIER_STATIC)) {
      var fieldName = SyncCall(fields[i], 'getName')();
      var jsfieldName = usableName(fieldName);
      result.__defineGetter__(jsfieldName, function(name, fieldName) {
        return java.getStaticFieldValue(name, fieldName);
      }.bind(this, name, fieldName));
      result.__defineSetter__(jsfieldName, function(name, fieldName, val) {
        java.setStaticFieldValue(name, fieldName, val);
      }.bind(this, name, fieldName));
    }
  }

  var promisify = undefined;
  var promiseSuffix;
  if (java.asyncOptions &amp;&amp; java.asyncOptions.promisify) {
    promisify = java.asyncOptions.promisify;
    promiseSuffix = java.asyncOptions.promiseSuffix;
  }

  // copy static methods
  var methods = SyncCall(clazz, 'getDeclaredMethods')();
  for (i = 0; i &lt; methods.length; i++) {
    var modifiers = SyncCall(methods[i], 'getModifiers')();
    if (((modifiers &amp; MODIFIER_PUBLIC) === MODIFIER_PUBLIC)
      &amp;&amp; ((modifiers &amp; MODIFIER_STATIC) === MODIFIER_STATIC)) {
      var methodName = SyncCall(methods[i], 'getName')();

      if (_.isString(syncSuffix)) {
        var syncName = usableName(methodName + syncSuffix);
        result[syncName] = java.callStaticMethodSync.bind(java, name, methodName);
      }

      if (_.isString(asyncSuffix)) {
        var asyncName = usableName(methodName + asyncSuffix);
        result[asyncName] = java.callStaticMethod.bind(java, name, methodName);
      }

      if (promisify &amp;&amp; _.isString(promiseSuffix)) {
        var promiseName = usableName(methodName + promiseSuffix);
        result[promiseName] = promisify(java.callStaticMethod.bind(java, name, methodName));
      }
    }
  }

  // copy static classes/enums
  var classes = SyncCall(clazz, 'getDeclaredClasses')();
  for (i = 0; i &lt; classes.length; i++) {
    var modifiers = SyncCall(classes[i], 'getModifiers')();
    if (((modifiers &amp; MODIFIER_PUBLIC) === MODIFIER_PUBLIC)
      &amp;&amp; ((modifiers &amp; MODIFIER_STATIC) === MODIFIER_STATIC)) {
      var className = SyncCall(classes[i], 'getName')();
      var simpleName = SyncCall(classes[i], 'getSimpleName')();
      Object.defineProperty(result, simpleName, {
        get: function(result, simpleName, className) {
          var c = java.import(className);

          // memoize the import
          var d = Object.getOwnPropertyDescriptor(result, simpleName);
          d.get = function(c) { return c; }.bind(null, c);
          Object.defineProperty(result, simpleName, d);

          return c;
        }.bind(this, result, simpleName, className),
        enumerable: true,
        configurable: true
      });
    }
  }

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
npm install java
```

Then create a file called `test.js` with the following contents

```
var java = require('java');
var javaLangSystem = java.<span class="apidocCodeKeywordSpan">import</span>('java.lang.System');

javaLangSystem.out.printlnSync('Hello World');
```

Then run

```bash
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.java.nodeJavaBridge.isJvmCreated" id="apidoc.element.java.nodeJavaBridge.isJvmCreated">
        function <span class="apidocSignatureSpan">java.nodeJavaBridge.</span>isJvmCreated
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isJvmCreated = function () {
  return typeof java.onJvmCreated !== 'function';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
    });

    var thread = java.newInstanceSync("java.lang.Thread", myProxy);
    thread.start();

&lt;a name="javaisJvmCreated" /&gt;
**java.<span class="apidocCodeKeywordSpan">isJvmCreated</span>()**

Returns true if the JVM has been created. The JVM can only be created once.

&lt;a name="javaRegisterClient" /&gt;
**java.registerClient(before, after)**

Register that a client wants to be called back immediately before and/or immediately after the JVM is created. If used, this function
 must be called before the JVM has been created. The before function is typically used to add to the classpath. The function may
 execute asynchronous operations (such as a async glob function). The after function is sometimes useful for doing one-time initialization
 that requires the JVM to first be initialized. If either function is unnecessary, use `null` or `undefined`. See also `registerClientP
` and `ensureJvm`. See the unit tests in `testAsyncOptions` for examples.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.java.nodeJavaBridge.onJvmCreated" id="apidoc.element.java.nodeJavaBridge.onJvmCreated">
        function <span class="apidocSignatureSpan">java.nodeJavaBridge.</span>onJvmCreated
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onJvmCreated = function () {
  if (java.asyncOptions) {
    syncSuffix = java.asyncOptions.syncSuffix;
    asyncSuffix = java.asyncOptions.asyncSuffix;
    if (typeof syncSuffix !== 'string') {
      throw new Error('In asyncOptions, syncSuffix must be defined and must a string');
    }
    var promiseSuffix = java.asyncOptions.promiseSuffix;
    var promisify = java.asyncOptions.promisify;
    if (typeof promiseSuffix === 'string' &amp;&amp; typeof promisify === 'function') {
      var methods = ['newInstance', 'callMethod', 'callStaticMethod'];
      methods.forEach(function (name) {
        java[name + promiseSuffix] = promisify(java[name]);
      });
    } else if (typeof promiseSuffix === 'undefined' &amp;&amp; typeof promisify === 'undefined') {
      // no promises
    } else {
      throw new Error('In asyncOptions, if either promiseSuffix or promisify is defined, both most be.');
    }

    if (_.isString(java.asyncOptions.ifReadOnlySuffix) &amp;&amp; java.asyncOptions.ifReadOnlySuffix !== '') {
      ifReadOnlySuffix = java.asyncOptions.ifReadOnlySuffix;
    }
  } else {
    syncSuffix = 'Sync';
    asyncSuffix = '';
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.java.nodeJavaBridge.registerClient" id="apidoc.element.java.nodeJavaBridge.registerClient">
        function <span class="apidocSignatureSpan">java.nodeJavaBridge.</span>registerClient
        <span class="apidocSignatureSpan">(before, after)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerClient = function (before, after) {
  var before_, after_;
  if (java.isJvmCreated()) {
    throw new Error('java.registerClient() called after JVM already created.');
  }
  before_ = (before &amp;&amp; before.length === 0) ?
    function(cb) { before(); cb(); } :
    before;

  after_ = (after &amp;&amp; after.length === 0) ?
    function(cb) { after(); cb(); } :
    after;

  clients.push({before: before_, after: after_});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;a name="javaisJvmCreated" /&gt;
**java.isJvmCreated()**

Returns true if the JVM has been created. The JVM can only be created once.

&lt;a name="javaRegisterClient" /&gt;
**java.<span class="apidocCodeKeywordSpan">registerClient</span>(before, after)**

Register that a client wants to be called back immediately before and/or immediately after the JVM is created. If used, this function
 must be called before the JVM has been created. The before function is typically used to add to the classpath. The function may
 execute asynchronous operations (such as a async glob function). The after function is sometimes useful for doing one-time initialization
 that requires the JVM to first be initialized. If either function is unnecessary, use `null` or `undefined`. See also `registerClientP
` and `ensureJvm`. See the unit tests in `testAsyncOptions` for examples.

&lt;a name="javaRegisterClientP" /&gt;
**java.registerClientP(before, after)**

Like java.registerClient, but before and after are assumed to be functions returning promises.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.java.nodeJavaBridge.registerClientP" id="apidoc.element.java.nodeJavaBridge.registerClientP">
        function <span class="apidocSignatureSpan">java.nodeJavaBridge.</span>registerClientP
        <span class="apidocSignatureSpan">(beforeP, afterP)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerClientP = function (beforeP, afterP) {
  if (java.isJvmCreated()) {
    throw new Error('java.registerClient() called after JVM already created.');
  }
  clients.push({beforeP: beforeP, afterP: afterP});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;a name="javaRegisterClient" /&gt;
**java.registerClient(before, after)**

Register that a client wants to be called back immediately before and/or immediately after the JVM is created. If used, this function
 must be called before the JVM has been created. The before function is typically used to add to the classpath. The function may
 execute asynchronous operations (such as a async glob function). The after function is sometimes useful for doing one-time initialization
 that requires the JVM to first be initialized. If either function is unnecessary, use `null` or `undefined`. See also `registerClientP
` and `ensureJvm`. See the unit tests in `testAsyncOptions` for examples.

&lt;a name="javaRegisterClientP" /&gt;
**java.<span class="apidocCodeKeywordSpan">registerClientP</span>(before, after)**

Like java.registerClient, but before and after are assumed to be functions returning promises.

&lt;a name="javaEnsureJvm" /&gt;
**java.ensureJvm(callback)**

If the JVM has not yet been created, execute the full JVM initialization process, then call callback function when initialization
 is complete. If the JVM has been created, just call the callback. Note that the full initialization process includes: 1) executing
 all registered client *before* hooks, 2) creating the JVM, then 3) executing all registered client *after* hooks.
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.java.testAsyncSuffixSyncDefault" id="apidoc.module.java.testAsyncSuffixSyncDefault">module java.testAsyncSuffixSyncDefault</a></h1>


    <h2>
        <a href="#apidoc.element.java.testAsyncSuffixSyncDefault.launch" id="apidoc.element.java.testAsyncSuffixSyncDefault.launch">
        function <span class="apidocSignatureSpan">java.testAsyncSuffixSyncDefault.</span>launch
        <span class="apidocSignatureSpan">(test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">launch = function (test) {
  test.expect(4);
  java.asyncOptions = {
    syncSuffix: "",
    asyncSuffix: "Async",
    ifReadOnlySuffix: "_alt"
  };

  function before(callback) {
    java.classpath.push('test/');
    test.ok(!java.isJvmCreated());
    callback();
  }

  function after(callback) {
    test.ok(java.isJvmCreated());
    callback();
  }

  java.registerClient(before, after);

  java.ensureJvm(function(err) {
    test.ifError(err);
    test.ok(java.isJvmCreated());
    test.done();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.java.testAsyncSuffixSyncDefault.testAPI" id="apidoc.element.java.testAsyncSuffixSyncDefault.testAPI">
        function <span class="apidocSignatureSpan">java.testAsyncSuffixSyncDefault.</span>testAPI
        <span class="apidocSignatureSpan">(test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testAPI = function (test) {
  test.expect(5);
  var arrayList = java.newInstanceSync("java.util.ArrayList");
  test.ok(arrayList);
  test.ok(java.instanceOf(arrayList, "java.util.ArrayList"));

  test.ok(!_.isUndefined(arrayList.addAsync), 'Expected `addAsync` to be present, but it is NOT.');
  test.ok(!_.isUndefined(arrayList.add), 'Expected `add` to be present, but it is NOT.');
  test.ok(_.isUndefined(arrayList.addPromise), 'Expected `addPromise` to NOT be present, but it is.');
  test.done();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.java.testAsyncSuffixSyncDefault.testAlternateMethodNameWorks" id="apidoc.element.java.testAsyncSuffixSyncDefault.testAlternateMethodNameWorks">
        function <span class="apidocSignatureSpan">java.testAsyncSuffixSyncDefault.</span>testAlternateMethodNameWorks
        <span class="apidocSignatureSpan">(test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testAlternateMethodNameWorks = function (test) {
  test.expect(4);
  var Test = java.import("Test");
  test.ok(Test);
  test.strictEqual(Test.name_alt(), "name");
  test.strictEqual(Test.caller_alt(), "caller");
  test.strictEqual(Test.arguments_alt(), "arguments");
  test.done();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.java.testAsyncSuffixSyncDefault.testAsyncCalls" id="apidoc.element.java.testAsyncSuffixSyncDefault.testAsyncCalls">
        function <span class="apidocSignatureSpan">java.testAsyncSuffixSyncDefault.</span>testAsyncCalls
        <span class="apidocSignatureSpan">(test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testAsyncCalls = function (test) {
  test.expect(4);
  var arrayList = java.newInstanceSync("java.util.ArrayList");
  arrayList.addAsync("hello", function(err, result) {
    test.ifError(err);
    arrayList.addAsync("world", function(err, result) {
      test.ifError(err);
      arrayList.sizeAsync(function(err, size) {
        test.ifError(err);
        test.strictEqual(size, 2);
        test.done();
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.java.testAsyncSuffixSyncDefault.testImportClass" id="apidoc.element.java.testAsyncSuffixSyncDefault.testImportClass">
        function <span class="apidocSignatureSpan">java.testAsyncSuffixSyncDefault.</span>testImportClass
        <span class="apidocSignatureSpan">(test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testImportClass = function (test) {
  test.expect(3);
  // Note: java.import executes javascript code in lib/nodeJavaBridge that makes sync calls to java classes.
  var ArrayList = java.import("java.util.ArrayList");
  test.ok(ArrayList);
  var arrayList = new ArrayList();
  test.ok(arrayList);
  test.strictEqual(arrayList.size(), 0);
  test.done();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.java.testAsyncSuffixSyncDefault.testReservedFieldName" id="apidoc.element.java.testAsyncSuffixSyncDefault.testReservedFieldName">
        function <span class="apidocSignatureSpan">java.testAsyncSuffixSyncDefault.</span>testReservedFieldName
        <span class="apidocSignatureSpan">(test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testReservedFieldName = function (test) {
  test.expect(7);
  var TestEnum = java.import("Test$Enum");
  test.ok(TestEnum);

  // 'foo' and 'bar' are valid enum names
  test.strictEqual(TestEnum.foo.toString(), "foo");
  test.strictEqual(TestEnum.bar.toString(), "bar");

  // TestEnum.name is actually the name of the proxy constructor function.
  test.strictEqual(TestEnum.name, "javaClassConstructorProxy");

  // Instead we need to acccess TestEnum.name_alt
  test.strictEqual(TestEnum.name_alt.toString(), "name");
  test.strictEqual(TestEnum.caller_alt.toString(), "caller");
  test.strictEqual(TestEnum.arguments_alt.toString(), "arguments");

  test.done();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.java.testAsyncSuffixSyncDefault.testStaticAPI" id="apidoc.element.java.testAsyncSuffixSyncDefault.testStaticAPI">
        function <span class="apidocSignatureSpan">java.testAsyncSuffixSyncDefault.</span>testStaticAPI
        <span class="apidocSignatureSpan">(test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testStaticAPI = function (test) {
  test.expect(6);
  var String = java.import("java.lang.String");
  test.ok(String);

  var api = _.functions(String);
  test.ok(_.includes(api, 'format'), 'Expected `format` to be present, but it is NOT.');
  test.ok(_.includes(api, 'formatAsync'), 'Expected `formatAsync` to be present, but it is NOT.');
  test.ok(!_.includes(api, 'formatSync'), 'Expected `formatSync` to NOT be present, but it is.');
  test.ok(!_.includes(api, 'formatPromise'), 'Expected `formatPromise` to NOT be present, but it is.');
  test.ok(!_.includes(api, 'formatundefined'), 'Expected `formatundefined` to NOT be present, but it is.');
  test.done();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.java.testAsyncSuffixSyncDefault.testStaticSyncCalls" id="apidoc.element.java.testAsyncSuffixSyncDefault.testStaticSyncCalls">
        function <span class="apidocSignatureSpan">java.testAsyncSuffixSyncDefault.</span>testStaticSyncCalls
        <span class="apidocSignatureSpan">(test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testStaticSyncCalls = function (test) {
  test.expect(1);
  // Note: java.import executes javascript code in lib/nodeJavaBridge that makes sync calls to java classes.
  // Among other things, java.import creates Sync functions for static methods.
  var String = java.import("java.lang.String");
  test.strictEqual(String.format('%s--%s', "hello", "world"), "hello--world");
  test.done();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.java.testAsyncSuffixSyncDefault.testSyncCalls" id="apidoc.element.java.testAsyncSuffixSyncDefault.testSyncCalls">
        function <span class="apidocSignatureSpan">java.testAsyncSuffixSyncDefault.</span>testSyncCalls
        <span class="apidocSignatureSpan">(test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testSyncCalls = function (test) {
  test.expect(1);
  var arrayList = java.newInstanceSync("java.util.ArrayList");
  arrayList.add("hello");
  arrayList.add("world");
  test.strictEqual(arrayList.size(), 2);
  test.done();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.java.testAsyncSuffixSyncDefault.testUnusableMethodNameThrows" id="apidoc.element.java.testAsyncSuffixSyncDefault.testUnusableMethodNameThrows">
        function <span class="apidocSignatureSpan">java.testAsyncSuffixSyncDefault.</span>testUnusableMethodNameThrows
        <span class="apidocSignatureSpan">(test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testUnusableMethodNameThrows = function (test) {
  test.expect(1);
  var Test = java.import("Test");
  test.ok(Test);
  test.throws(
    function() {
      Test.name();
    },
    function(err) {
      if (err instanceof TypeError) {
        test.done();
        return true;
      } else {
        test.done(err);
        return false;
      }
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.java.testDefactoPlusPromise" id="apidoc.module.java.testDefactoPlusPromise">module java.testDefactoPlusPromise</a></h1>


    <h2>
        <a href="#apidoc.element.java.testDefactoPlusPromise.launch" id="apidoc.element.java.testDefactoPlusPromise.launch">
        function <span class="apidocSignatureSpan">java.testDefactoPlusPromise.</span>launch
        <span class="apidocSignatureSpan">(test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">launch = function (test) {
  test.expect(7);
  var api = _.functions(java);
  test.ok(_.includes(api, 'isJvmCreated'), 'Expected `isJvmCreated` to be present, but it is NOT.');
  test.ok(!java.isJvmCreated());

  java.asyncOptions = {
    syncSuffix: "Sync",
    asyncSuffix: "",
    promiseSuffix: 'Promise',
    promisify: require('when/node').lift         // https://github.com/cujojs/when
  };

  function before(callback) {
    test.ok(!java.isJvmCreated());
    callback();
  }

  function after(callback) {
    test.ok(java.isJvmCreated());
    callback();
  }

  java.registerClient(before, after);
  java.registerClient(null, after);
  java.registerClient(before);

  java.ensureJvm().done(function() {
    test.ok(java.isJvmCreated());
    test.done();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.java.testDefactoPlusPromise.testAPI" id="apidoc.element.java.testDefactoPlusPromise.testAPI">
        function <span class="apidocSignatureSpan">java.testDefactoPlusPromise.</span>testAPI
        <span class="apidocSignatureSpan">(test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testAPI = function (test) {
  test.expect(5);
  var arrayList = java.newInstanceSync("java.util.ArrayList");
  test.ok(arrayList);
  test.ok(java.instanceOf(arrayList, "java.util.ArrayList"));

  test.ok(!_.isUndefined(arrayList.addSync), 'Expected `addSync` to be present, but it is NOT.');
  test.ok(!_.isUndefined(arrayList.add), 'Expected `add` to be present, but it is NOT.');
  test.ok(!_.isUndefined(arrayList.addPromise), 'Expected `addPromise` to be present, but it is NOT.');
  test.done();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.java.testDefactoPlusPromise.testAsyncCalls" id="apidoc.element.java.testDefactoPlusPromise.testAsyncCalls">
        function <span class="apidocSignatureSpan">java.testDefactoPlusPromise.</span>testAsyncCalls
        <span class="apidocSignatureSpan">(test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testAsyncCalls = function (test) {
  test.expect(4);
  var arrayList = java.newInstanceSync("java.util.ArrayList");
  arrayList.add("hello", function(err, result) {
    test.ifError(err);
    arrayList.add("world", function(err, result) {
      test.ifError(err);
      arrayList.size(function(err, size) {
        test.ifError(err);
        test.strictEqual(size, 2);
        test.done();
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.java.testDefactoPlusPromise.testImportClass" id="apidoc.element.java.testDefactoPlusPromise.testImportClass">
        function <span class="apidocSignatureSpan">java.testDefactoPlusPromise.</span>testImportClass
        <span class="apidocSignatureSpan">(test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testImportClass = function (test) {
  test.expect(3);
  // Note: java.import executes javascript code in lib/nodeJavaBridge that makes sync calls to java classes.
  var ArrayList = java.import("java.util.ArrayList");
  test.ok(ArrayList);
  var arrayList = new ArrayList();
  test.ok(arrayList);
  test.strictEqual(arrayList.sizeSync(), 0);
  test.done();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.java.testDefactoPlusPromise.testPromiseCalls" id="apidoc.element.java.testDefactoPlusPromise.testPromiseCalls">
        function <span class="apidocSignatureSpan">java.testDefactoPlusPromise.</span>testPromiseCalls
        <span class="apidocSignatureSpan">(test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testPromiseCalls = function (test) {
  test.expect(1);
  var arrayList = java.newInstanceSync("java.util.ArrayList");
  arrayList.addPromise("hello")
    .then(function () { return arrayList.addPromise("world"); })
    .then(function () { return arrayList.sizePromise(); })
    .then(function (size) {
      test.strictEqual(size, 2);
      test.done();
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.java.testDefactoPlusPromise.testStaticAPI" id="apidoc.element.java.testDefactoPlusPromise.testStaticAPI">
        function <span class="apidocSignatureSpan">java.testDefactoPlusPromise.</span>testStaticAPI
        <span class="apidocSignatureSpan">(test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testStaticAPI = function (test) {
  test.expect(6);
  var String = java.import("java.lang.String");
  test.ok(String);

  var api = _.functions(String);
  test.ok(_.includes(api, 'format'), 'Expected `format` to be present, but it is NOT.');
  test.ok(_.includes(api, 'formatSync'), 'Expected `formatSync` to be present, but it is NOT.');
  test.ok(_.includes(api, 'formatPromise'), 'Expected `formatPromise` to be present, but it is NOT.');
  test.ok(!_.includes(api, 'formatAsync'), 'Expected `formatAsync` to NOT be present, but it is.');
  test.ok(!_.includes(api, 'formatundefined'), 'Expected `formatundefined` to NOT be present, but it is.');
  test.done();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.java.testDefactoPlusPromise.testStaticSyncCalls" id="apidoc.element.java.testDefactoPlusPromise.testStaticSyncCalls">
        function <span class="apidocSignatureSpan">java.testDefactoPlusPromise.</span>testStaticSyncCalls
        <span class="apidocSignatureSpan">(test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testStaticSyncCalls = function (test) {
  test.expect(1);
  // Note: java.import executes javascript code in lib/nodeJavaBridge that makes sync calls to java classes.
  // Among other things, java.import creates Sync functions for static methods.
  var String = java.import("java.lang.String");
  test.strictEqual(String.formatSync('%s--%s', "hello", "world"), "hello--world");
  test.done();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.java.testDefactoPlusPromise.testSyncCalls" id="apidoc.element.java.testDefactoPlusPromise.testSyncCalls">
        function <span class="apidocSignatureSpan">java.testDefactoPlusPromise.</span>testSyncCalls
        <span class="apidocSignatureSpan">(test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testSyncCalls = function (test) {
  test.expect(1);
  var arrayList = java.newInstanceSync("java.util.ArrayList");
  arrayList.addSync("hello");
  arrayList.addSync("world");
  test.strictEqual(arrayList.sizeSync(), 2);
  test.done();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>